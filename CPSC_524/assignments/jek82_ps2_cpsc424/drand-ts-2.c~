#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <omp.h>

static uint64_t seed;
static uint8_t key = 1;
// set seed and key to threadprivate so each thread has its own copies
#pragma omp threadprivate(seed, key)

void dsrand(unsigned s)
{
  seed = s-1;
  printf("Seed = %lu. RAND_MAX = %d.\n",seed,RAND_MAX);
}

/* The issue with giving each thread its private copy of seed is that, 
   while it takes care of dependencies of the variable itself between each 
   thread, note that this is a PSEUDOrandom number generator. In particular,
   without modifying the generator, the sequence of numbers generated by 
   each thread will be identical. This is a huge problem and actually makes 
   the dependencies worse!! However, it is one part of the solution; the 
   next is to ensure that the sequence of pseudorandom numbers generated 
   within each thread are different. Fortunately, the shift map is chaotic, 
   so a small difference in the initial seed will drastically change the 
   random numbers produced. Let us use that to our advantage. */

double drand(void)
{
  // make critical to check seed gets updated in each thread separately
  #pragma omp critical
  {
    if (key) {
      // shift initial seed by the thread number
      seed += omp_get_thread_num();
      key = 0;
    }
  }
  #pragma omp atomic
  seed *= 6364136223846793005ULL;
  #pragma omp atomic
  seed += 1;
  return((double)(seed>>33)/(double)RAND_MAX);
}
